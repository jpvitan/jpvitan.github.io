<a href="blogs/computer-science/how-i-implemented-the-rsa-algorithm-in-python/banner.png">
    <img class="img-fluid border mb-4"
        src="blogs/computer-science/how-i-implemented-the-rsa-algorithm-in-python/banner.png" width="1366" height="768"
        alt="rsa-jpv on GitHub">
</a>

<p>The RSA is an asymmetric encryption algorithm that is widely adopted by today’s modern systems to secure data. It is
    usually paired with another encryption algorithm due to its slow performance. In this post, we are going to
    implement the “pure” and “textbook” version of RSA using Python 3.</p>

<h2 class="mt-5 mb-3">Key Generation</h2>

<p>RSA uses two different keys to encrypt and decrypt data. In this context, we use the public key to encrypt the data
    and the private key to decrypt it.</p>

<p>The public key consists of two integers $e$ and $n$. The public key can't be used to decrypt messages and you may
    distribute it to anyone who wants to send you encrypted messages. Similarly, the private key also consists of two
    integers $d$ and $n$ but unlike the public key, you should always keep your private key a secret.</p>

<p>The values of the public and private key rely on two large and distinct prime numbers $p$ and $q$. There are
    generally factors to consider when choosing $p$ and $q$ but for the sake of simplicity, we are just going to assume
    that $p$ and $q$ are distinct prime numbers.</p>

<p>After we have defined the values for $p$ and $q$, we can now compute $n$ and $k$. $n$ is simply the product of $p$
    and $q$ and $k$ is $\phi(n)$ or the number of relatively prime integers to $n$ from $[1,n]$.</p>

$$
\begin{align}
n &= p \cdot q \\[1.2ex]
k &= \phi(n) = (p-1)(q-1)
\end{align}
$$

<p>The only thing that is left to compute are the auxiliary values $e$ and $d$. The value of $e$ could be any integer as
    long as it satisfies the condition that it is relatively prime to $k$ and greater than one. The value of $d$ is the
    multiplicative inverse of $e \ \textrm{mod} \ k$.</p>

<h2 class="mt-5 mb-3">Programming the Key Generator</h2>

<p>For this part, I'm going to focus solely on getting $e$ and $d$ and skip the code for generating random prime numbers
    as it is quite trivial.</p>

<p>We could find $e$ by creating two functions:</p>
<ol>
    <li>A function that finds the gcd of two numbers</li>
    <li>A function that tests certain values if they are relatively prime to a given input</li>
</ol>

<p>The code below shows exactly how we could get $e$ by using those two functions.</p>

<pre class="my-4">
<code class="language-python">
# This function finds the gcd of two integers using the Euclidean algorithm.
def gcd(x: int, y: int) -> int:
    if x > y:
        temp = y
        y = x
        x = temp
    if x == 0:
        return y

    while True:
        r = y % x
        if r == 0:
            break
        y = x
        x = r
    return x
    
# This function finds the first number that is relatively prime to the parameter (x).
def find_number_relatively_prime(x: int, starting_number=3) -> int:
    y = starting_number
    while True:
        if gcd(y, x) == 1:
            break
        y = y + 1
    return y
    
# To find (e), we simply do this:
k = 40
e = find_number_relatively_prime(k)
print(e)  # Output: 3
</code>
</pre>

<p>Finding $d$ requires us to slightly modify our <code>gcd()</code> function and solve a recurrence relation that gives
    the linear combination of $e$ and $k$.</p>

<pre class="my-4">
<code class="language-python">
# This function gives the linear combination of (x) and (y) in xa + yb = gcd(x,y).
def gcd_linear_combination(x: int, y: int) -> tuple:
    if x > y:
        temp = y
        y = x
        x = temp
    if x == 0:
        return y

    original_x = x
    original_y = y

    coefficient_list = []
    coefficient_list.append((0, 1))
    coefficient_list.append((1, -int(y / x)))

    iteration = 1

    while True:
        r = y % x
        if r == 0:
            break

        # Solve the recurrence relation.
        if iteration != 1:
            quotient = int(y / x)
            a = int(coefficient_list[iteration - 2][0] - (coefficient_list[iteration - 1][0] * quotient))
            b = int(coefficient_list[iteration - 2][1] - (coefficient_list[iteration - 1][1] * quotient))
            coefficient_list.append((a, b))

        y = x
        x = r
        iteration = iteration + 1

    a = coefficient_list[-1][1]
    b = coefficient_list[-1][0]

    # If (a) is negative, make it positive to avoid negative exponents.
    if a < 0:
        i = 2
        while True:
            a_candidate = a + i * original_y
            b_candidate = b - i * original_x

            if a_candidate > 0:
                a = a_candidate
                b = b_candidate
                break
            i = i + 1
    return a, b

# To find (d) for ex + ky = gcd(e,k) = 1:
e = 3
k = 40
x = gcd_linear_combination(e,k)[0]
d = x % k
print(d)  # Output: 27
</code>
</pre>

<p>Combining those functions we have, we could now generate a public and private key.</p>

<pre class="my-4">
<code class="language-python">
# Public and private key sample for p = 5 and q = 11.
p = 5
q = 11
n = p * q  # n = 55
k = (p-1) * (q-1)  # k = 40
e = find_number_relatively_prime(k)  # e = 3
d = gcd_linear_combination(e, k)[0] % k  # d = 27
</code>
</pre>

<h2 class="mt-5 mb-3">Encrypting and Decrypting Messages</h2>

<p>Encrypting and decrypting a message in RSA is relatively easy and straightforward.</p>

<p>To encrypt a message $m$:</p>
$$m' = m^e\ \textrm{mod}\ n$$

<p>To decrypt:</p>
$$m = (m')^d\ \textrm{mod}\ n$$

<p>The code below shows a sample encryption-decryption process.</p>

<pre class="my-4">
<code class="language-python">
# Encryption and decryption sample for m = 8, n = 55, e = 3, and d = 27.
m = 8
n = 55
e = 3
d = 27
encrypted_m = m**e % n  # encrypted_m = 17
decrypted_m = encrypted_m**d % n  # decrypted_m = 8
</code>
</pre>