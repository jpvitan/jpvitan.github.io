<a href="blogs/computer-science/how-i-implemented-the-rsa-algorithm-in-python/banner.png">
    <img class="img-fluid border mb-4" src="blogs/computer-science/how-i-implemented-the-rsa-algorithm-in-python/banner.png" width="1366" height="768" alt="rsa-jpv on GitHub">
</a>

<p>The Rivest-Shamir-Adleman algorithm or simply the "RSA" is an asymmetric cryptographic algorithm that is widely used today to secure data. It is usually paired with another cryptographic algorithm since RSA is quite slow.</p>

<p>This post will cover everything from number theory to its implementation in Python. The math involved isn't too hard but will require you to at least understand a bit of number theory.</p>

<p>You could view the library <a href="https://github.com/jpvitan/rsa-jpv" style="text-decoration: none; color: #0fbcf9;">here</a>.</p>

<div style="height: 1rem;"></div>

<h2>Generating the Keys</h2>

<p>RSA is an asymmetric cryptographic algorithm, which means that the keys used for encryption and decryption are different. In this context, we use the public key to encrypt the data and the private key to decrypt it.</p>

<a href="blogs/computer-science/how-i-implemented-the-rsa-algorithm-in-python/key.png">
    <img class="img-fluid border mb-4" src="blogs/computer-science/how-i-implemented-the-rsa-algorithm-in-python/key.png" width="1050" height="1026" alt="Key">
</a>

<p>The public key consists of two integers $e$ and $n$. The public key can't be used to decrypt messages and you may distribute it to anyone who wants to send you encrypted messages. Similarly, the private key also consists of two integers $d$ and $n$ but unlike the public key, you should always keep your private key a secret.</p>

<p>The values of the public and private key rely on two large and distinct prime numbers:</p>
$$p,q \in \textrm{primes}\hspace{5mm} \textrm{where}\ p \neq q$$

<p>After choosing our $p$ and $q$, we now define $n$ and $k$:</p>
$$
\begin{align}
n &= p \cdot q \\[1.2ex]
k &= \phi(n) = (p-1)(q-1)
\end{align}
$$

<p>$n$ is simply the product of $p$ and $q$ and $k$ is $\phi(n)$ or the Euler totient function taken on $n$.</p>

<p>The next thing that we need to do is calculate $e$ and $d$ or the auxiliary value for the public and private key:</p>
$$
\begin{align}
&\mathbb{Z}_k = [0,k) \\[1.2ex]
&\exists e \in \mathbb{N} : \textrm{gcd}(e, k) = 1,\ e > 1 \\[1.2ex]
&\exists d \in \mathbb{Z}_k : e \cdot d \equiv 1\hspace{5mm} (\textrm{mod}\ k)
\end{align}
$$

<p>The value of $e$ could be any number as long as it satisfies the condition that it is relatively prime to $k$ and greater than one while the value of $d$ is the multiplicative inverse of $e$ in $\mathbb{Z}_k$.</p>

<p>To get $d$, we are going to use the extended Euclidean algorithm:</p>
$$ex + ky = \textrm{gcd}(e, k) = 1\hspace{5mm} \textrm{where}\ x,y \in \mathbb{Z}$$

<p>Since $ex + ky = 1 \implies ex + ky \equiv 1\ (\textrm{mod}\ k)$:</p>
$$
\begin{align}
ex + ky &\equiv 1\hspace{5mm} (\textrm{mod}\ k) \\[1.2ex]
ex + 0 &\equiv 1\hspace{5mm} (\textrm{mod}\ k)
\end{align}
$$

<p>This means that the value of $d$ is:</p>
$$d = x\ \textrm{mod}\ k$$ 

<div class="border px-2 py-2">
<h3>Example</h3>

<p>Let's try to generate a public and private key for the following values:</p>
$$
\begin{align}
p &= 5 \\[1.2ex]
q &= 11 \\[1.2ex]
n &= 55 = 5 \cdot 11 \\[1.2ex]
k &= 40 = 4 \cdot 10
\end{align}
$$

<p>For the value of $e$, we could choose $e=3$ since $\textrm{gcd}(3, 40)=1$. We could verify this using the Euclidean algorithm:</p>
$$
\begin{align}
40 &= 3 \cdot 13 + 1 \\[1.2ex]
3 &= 1 \cdot 3 + 0
\end{align}
$$

<p>To find $d$, we are going to use the extended Euclidean algorithm and we'll end up with:</p>
$$
\begin{align}
ex + ky &= 1 \\[1.2ex]
3 \cdot (-13) + 40 \cdot 1 &= 1
\end{align}
$$

<p>Using the laws of remainder arithmetic, we could see that the value of $d$ is:</p>
$$d = -13\ \textrm{mod}\ 40 = 27$$

<p>For this example, the public key has the values $e=3$ and $n=55$, and the private key has the values $d=27$ and $n=55$.</p>
</div>

<div style="height: 2rem;"></div>

<h2>Programming the Key Generator</h2>

<p>For this part, I'm going to skip the code for generating random prime numbers and focus solely on getting $e$ and $d$.</p>

<p>To find $e$, we need to create two functions:</p>
<ol>
    <li>A function that finds the gcd of two numbers</li>
    <li>A function that tests certain values if they are relatively prime to a given input</li>
</ol>

<pre>
<code class="language-python">
# This function finds the gcd of two integers using the Euclidean algorithm.
def gcd(x: int, y: int) -> int:
    if x > y:
        temp = y
        y = x
        x = temp
    if x == 0:
        return y

    while True:
        r = y % x
        if r == 0:
            break
        y = x
        x = r
    return x
   
# This function finds the first number that is relatively prime to the parameter (x).
def find_number_relatively_prime(x: int, starting_number=3) -> int:
    y = starting_number
    while True:
        if gcd(y, x) == 1:
            break
        y = y + 1
    return y
    
# To find (e), we simply do this:
k = 40
e = find_number_relatively_prime(k)
print(e)  # Output: 3
</code>
</pre>

<div style="height: 1rem;"></div>

<p>Finding $d$ requires us to solve the linear combination of $e$ and $k$ since $ex + ky = \textrm{gcd}(e, k) = 1$ and $d = x\ \textrm{mod}\ k$. We could do this by slightly modifying the <code>gcd()</code> function we have and solving a recurrence relation that gives the linear combination of $e$ and $k$.</p>
<pre>
<code class="language-python">
# This function gives the linear combination of (x) and (y) in xa + yb = gcd(x,y).
def gcd_linear_combination(x: int, y: int) -> tuple:
    if x > y:
        temp = y
        y = x
        x = temp
    if x == 0:
        return y

    original_x = x
    original_y = y

    coefficient_list = []
    coefficient_list.append((0, 1))
    coefficient_list.append((1, -int(y / x)))

    iteration = 1

    while True:
        r = y % x
        if r == 0:
            break

        # Solve the recurrence relation.
        if iteration != 1:
            quotient = int(y / x)
            a = int(coefficient_list[iteration - 2][0] - (coefficient_list[iteration - 1][0] * quotient))
            b = int(coefficient_list[iteration - 2][1] - (coefficient_list[iteration - 1][1] * quotient))
            coefficient_list.append((a, b))

        y = x
        x = r
        iteration = iteration + 1

    a = coefficient_list[-1][1]
    b = coefficient_list[-1][0]

    # If (a) is negative, make it positive to avoid negative exponents.
    if a < 0:
        i = 2
        while True:
            a_candidate = a + i * original_y
            b_candidate = b - i * original_x

            if a_candidate > 0:
                a = a_candidate
                b = b_candidate
                break
            i = i + 1
    return a, b

# To find (d) for ex + ky = gcd(e,k) = 1:
e = 3
k = 40
x = gcd_linear_combination(e,k)[0]
d = x % k
print(d)  # Output: 27
</code>
</pre>

<div style="height: 1rem;"></div>

<p>Combining those functions we have, we could now generate a public and private key:</p>
<pre>
<code class="language-python">
def generate_key_pair(first_prime: int = None, second_prime: int = None) -> KeyPair:
    """
    A function that generates a public key and private key.
    Parameters:
    first_prime (int): The first prime number.
    second_prime (int): The second prime number.
    Returns:
    KeyPair: A class that holds the public key and private key.
    """

    # Generate two distinct primes.
    prime_pair = rmath.generate_prime_number_list(size=2, shuffle=True)
    # Make sure primes are distinct.
    if first_prime is None:
        first_prime = prime_pair[0]
        if first_prime == second_prime:
            first_prime = prime_pair[1]
    if second_prime is None:
        second_prime = prime_pair[1]
        if first_prime == second_prime:
            second_prime = prime_pair[0]
    # Primality test.
    inputchecker.rsa_generate_key_pair(first_prime, second_prime)

    prime_product = first_prime * second_prime
    prime_product_minus_one = (first_prime - 1) * (second_prime - 1)
    public_auxiliary = rmath.find_number_relatively_prime(prime_product_minus_one)
    private_auxiliary = rmath.gcd_linear_combination(public_auxiliary, prime_product_minus_one)[0]

    # The Key class is just a holder for the values of the public and private key.
    public_key = Key(prime_product, public_auxiliary)
    private_key = Key(prime_product, private_auxiliary)
    key_pair = KeyPair(public_key, private_key)

    return key_pair
</code>
</pre>

<div style="height: 1rem;"></div>

<h2>Encrypting and Decrypting Messages</h2>

<p>Encrypting and decrypting a message in RSA is relatively easy and straightforward.</p>

<p>To encrypt a message $m$:</p>
$$m' = m^e\ \textrm{mod}\ n$$

<p>To decrypt:</p>
$$m = (m')^d\ \textrm{mod}\ n$$

<div class="border px-2 py-2">
<h3>Example</h3>

<p>Let's try to encrypt a message $m = 8$ with the following keys:</p>
$$
\begin{align}
e &= 3 \\[1.2ex]
d &= 27 \\[1.2ex]
n &= 55
\end{align}
$$

<p>This means that the value of $m'$ is:</p>
$$m' = 17 = 8^3\ \textrm{mod}\ 55$$

<p>To decrypt $m'$:</p>
$$m = 8 = 17^{27}\ \textrm{mod}\ 55$$
</div>

<div style="height: 1rem;"></div>

<p>If you want to encrypt strings, you could convert each character to their Unicode value (or any other numerical representation of the character) and do the math from there.</p>

<p>Here's how I programmed the encryption and decryption process in Python:</p>
<pre class="mb-4">
<code class="language-python">
class Encryptor:
    """
    A class that encrypts data based on the key parameter.
    Parameters:
    public_key (Key): The public key.
    """

    def __init__(self, public_key: Key):
        self.public_key = public_key

    def encrypt(self, message: str) -> str:
        """
        A method that takes a string and encrypts it.
        Parameters:
        message (str): The string to be encrypted.
        Returns:
        str: The encrypted string.
        """

        encrypted_message = ""
        for character in message:
            encrypted_character = chr((ord(character) ** self.public_key.auxiliary) % self.public_key.prime_product)
            encrypted_message = encrypted_message + encrypted_character
        return encrypted_message


class Decryptor:
    """
    A class that decrypts data based on the key parameter.
    Parameters:
    private_key (Key): The private key.
    """

    def __init__(self, private_key: Key):
        self.private_key = private_key

    def decrypt(self, message: str) -> str:
        """
        A method that takes a string and decrypts it.
        Parameters:
        message (str): The string to be decrypted.
        Returns:
        str: The decrypted string.
        """
        decrypted_message = ""
        for character in message:
            decrypted_character = chr((ord(character) ** self.private_key.auxiliary) % self.private_key.prime_product)
            decrypted_message = decrypted_message + decrypted_character
        return decrypted_message
</code>
</pre>