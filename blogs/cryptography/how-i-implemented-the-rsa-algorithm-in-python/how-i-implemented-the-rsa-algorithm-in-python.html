<img class="img-fluid border mb-4" src="blogs/cryptography/how-i-implemented-the-rsa-algorithm-in-python/banner.png">
<p>The Rivest-Shamir-Adleman algorithm or simply the "RSA" is an asymmetric cryptographic algorithm that is widely used today to secure data. It is usually paired with another cryptographic algorithm since RSA is known to be slow and expensive.</p>
<p>This post will cover everything from number theory to its implementation in Python. The math involved isn't too hard but will require you to at least understand a bit of number theory.</p>
<p>This post will assume that you know how to code in Python and you know how the euclidean algorithm works, including its extended version.</p>
<p>You could view the library <a href="https://github.com/jpvitan/rsa-jpv" style="text-decoration: none;">here</a>.</p>
<div class="header">Generating the Public Key and Private Key</div>
<p>RSA is an asymmetric cryptographic algorithm, which means that the keys used for encryption is not the same that is used for decryption. In this context, we use the public key to encrypt the data and the private key to decrypt it.</p>
<p>The values of the public key and private key rely on two large prime numbers which we would denote as:</p>
$$p,q \in \textrm{primes}\hspace{5mm} \textrm{where}\ p \neq q$$
<p>The security of RSA relies on the fact that it is hard to factor these two large primes, so we'll go ahead and define two variables that involve their product:</p>
$$n = p \cdot q$$
$$k = (p-1)(q-1)$$
<p>Notice that I am not very clear about the definition of what "large" is, that is because "large" is a very unstable term in computing. What might be considered large today might not be considered large 20 years from now.</p>
<p>We are almost finished with our public key, we just need to define one more variable:</p>
$$\exists e \in \mathbb{N} : \textrm{gcd}(e, k) = 1,\ e > 1$$
<p>If you are not used to mathematical symbols, the equation above might startle you but it's actually very simple. It just means that there exists $e$ in the set of natural numbers such that it is relatively prime to $k$ and greater than one. In number theory, we call two numbers relatively prime if their greatest common denominator (gcd) is one.</p>
<p>If you are just learning, $e$ could be any number as long as it satisfies the condition that it is relatively prime to $k$ and greater than one. In my library, I would choose the lowest possible value for $e$ with the condition that it is greater than or equal to three.</p>
<p>The public key is made out of two variables $e$ and $n$. The public key can't be used to decrypt messages and you may distribute it to anyone who wants to send you encrypted messages. Similarly, the private key is also made out of two variables $d$ and $n$ but unlike the public key, you should always keep your private key a secret.</p>
<p>The auxiliary value for the private key, which we would denote as $d$ is defined as:</p>
$$\exists d \in \mathbb{N} : e \cdot d \equiv 1\hspace{5mm} (\textrm{mod}\ k)$$
<p>To further explain the equation above, $d$ is the multiplicative inverse of $e$ in $\mathbb{Z}_k$. We know that $d$ exists because $\textrm{gcd}(e, k) = 1$ and by the extended euclidean algorithm:</p>
$$ex + ky = 1\hspace{5mm} \textrm{where}\ x,y \in \mathbb{Z}$$
<p>Since $a = b$ implies $a \equiv b\ (\textrm{mod}\ n)$:</p>
$$ex + ky \equiv 1\hspace{5mm} (\textrm{mod}\ k)$$
$$ex + 0 \equiv 1\hspace{5mm} (\textrm{mod}\ k)$$
<p>This means that:</p>
$$d = x\ \textrm{mod}\ k$$
<p>To clearly demonstrate this, let's try to generate a public key and private key for:</p>
$$p=5,\ q=11$$
$$n = 55 = 5 \cdot 11$$
$$k = 40 = 4 \cdot 10$$
<p>For the value of $e$, we could choose $e=3$ since $\textrm{gcd}(3, 40)=1$. We could try to verify this using the euclidean algorithm:</p>
$$40 = 3 \cdot 13 + 1$$
$$3 = 1 \cdot 3 + 0$$
<p>To find $d$, we are going to use the extended euclidean algorithm and we'll end up with:</p>
$$ex + ky = 1$$
$$ 3 \cdot (-13) + 40 \cdot 1 = 1$$
<p>Using the laws of remainder arithmetic, we could see that the value of $d$ is:</p>
$$d = -13\ \textrm{mod}\ 40 = 27$$
<p>For this example, the public key has the values $e=3$ and $n=55$ and the private key has the values $d=27$ and $n=55$.</p>
<p>Now that we are done with the math, let's try to dive into the code. For this part, I'm going to skip the code for generating random prime numbers since it's very easy to implement one on your own.</p>
<p>Our first challenge here is finding $e$. We could do this by first constructing a function that finds the gcd of two numbers and then constructing another function that tests certain values if they are relatively prime to a given input.</p>
<pre class="line-numbers">
<code class="language-python">
def gcd(x: int, y: int) -> int:
    if x > y:
        temp = y
        y = x
        x = temp
    if x == 0:
        return y

    while True:
        r = y % x
        if r == 0:
            break
        y = x
        x = r
    return x
    
def find_number_relatively_prime(x: int, starting_number=3) -> int:
    y = starting_number
    while True:
        if gcd(y, x) == 1:
            break
        y = y + 1
    return y
</code>
</pre>