<img class="img-fluid border mb-4" src="blogs/cryptography/how-i-implemented-the-rsa-algorithm-in-python/banner.png">

<p>The Rivest-Shamir-Adleman algorithm or simply the "RSA" is an asymmetric cryptographic algorithm that is widely used today to secure data. It is usually paired with another cryptographic algorithm since RSA is slow and expensive.</p>

<p>This post will cover everything from number theory to its implementation in Python. The math involved isn't too hard but will require you to at least understand a bit of number theory.</p>

<p>You could view the library <a href="https://github.com/jpvitan/rsa-jpv" style="text-decoration: none;">here</a>.</p>

<div style="height: 1rem;"></div>

<h2>The Math Behind the Public and Private Key</h2>

<p>RSA is an asymmetric cryptographic algorithm, which means that the keys used for encryption and decryption are different. In this context, we use the public key to encrypt the data and the private key to decrypt it.</p>

<p>The public key is made out of two integers $e$ and $n$. The public key can't be used to decrypt messages and you may distribute it to anyone who wants to send you encrypted messages. Similarly, the private key is also made out of two integers $d$ and $n$ but unlike the public key, you should always keep your private key a secret.</p>

<p>The values of the public and private key rely on two large prime numbers, which we would denote as:</p>
$$p,q \in \textrm{primes}\hspace{5mm} \textrm{where}\ p \neq q$$

<p>The security of RSA relies on the fact that it is hard to factor the product of these two large primes, so we'll go ahead and define two variables that involve their product:</p>
$$n = p \cdot q$$
$$k = \phi(n) = (p-1)(q-1)$$

<p>The auxiliary value ($e$) for the public key is defined as:</p>
$$\exists e \in \mathbb{N} : \textrm{gcd}(e, k) = 1,\ e > 1$$

<p>If you are just learning, $e$ could be any number as long as it satisfies the condition that it is relatively prime to $k$ and greater than one. In my library, I would choose the lowest possible value for $e$ with the condition that it is greater than or equal to three.</p>

<p>The auxiliary value ($d$) for the private key is defined as:</p>
$$\mathbb{Z}_k = [0,k)$$
$$\exists d \in \mathbb{Z}_k : e \cdot d \equiv 1\hspace{5mm} (\textrm{mod}\ k)$$

<p>$d$ is the multiplicative inverse of $e$ in $\mathbb{Z}_k$. We know that $d$ exists because $\textrm{gcd}(e, k) = 1$ and by the extended Euclidean algorithm:</p>
$$ex + ky = 1\hspace{5mm} \textrm{where}\ x,y \in \mathbb{Z}$$

<p>Since $a = b$ implies $a \equiv b\ (\textrm{mod}\ n)$:</p>
$$ex + ky \equiv 1\hspace{5mm} (\textrm{mod}\ k)$$
$$ex + 0 \equiv 1\hspace{5mm} (\textrm{mod}\ k)$$

<p>This means that:</p>
$$d = x\ \textrm{mod}\ k$$

<div class="border px-2 py-2">
<h3>Example</h3>

<p>Let's try to generate a public and private key for the following values:</p>
$$p=5,\ q=11$$
$$n = 55 = 5 \cdot 11$$
$$k = 40 = 4 \cdot 10$$

<p>For the value of $e$, we could choose $e=3$ since $\textrm{gcd}(3, 40)=1$. We could verify this using the Euclidean algorithm:</p>
$$40 = 3 \cdot 13 + 1$$
$$3 = 1 \cdot 3 + 0$$

<p>To find $d$, we are going to use the extended Euclidean algorithm and we'll end up with:</p>
$$ex + ky = 1$$
$$ 3 \cdot (-13) + 40 \cdot 1 = 1$$

<p>Using the laws of remainder arithmetic, we could see that the value of $d$ is:</p>
$$d = -13\ \textrm{mod}\ 40 = 27$$

<p>For this example, the public key has the values $e=3$ and $n=55$ and the private key has the values $d=27$ and $n=55$.</p>
</div>

<div style="height: 2rem;"></div>

<h2>Programming the Key Generator</h2>

<p>Our first challenge here is finding $e$. We could do this by first constructing a function that finds the gcd of two numbers and constructing another function that tests certain values if they are relatively prime to a given input.</p>
<pre class="line-numbers">
<code class="language-python">
# This function finds the gcd of two integers using the Euclidean algorithm.
def gcd(x: int, y: int) -> int:
    if x > y:
        temp = y
        y = x
        x = temp
    if x == 0:
        return y

    while True:
        r = y % x
        if r == 0:
            break
        y = x
        x = r
    return x
   
# This function finds the first number that is relatively prime to the parameter (x).
def find_number_relatively_prime(x: int, starting_number=3) -> int:
    y = starting_number
    while True:
        if gcd(y, x) == 1:
            break
        y = y + 1
    return y
    
# To find (e), we simply do this:
k = 40
e = find_number_relatively_prime(k)
print(e)  # Output: 3
</code>
</pre>

<div style="height: 1rem;"></div>

<p>Finding $d$ requires us to solve the linear combination of $e$ and $k$ since $ex + ky = \textrm{gcd}(e, k) = 1$ and $d = x\ \textrm{mod}\ k$. We could do this by slightly modifying the <code>gcd()</code> function we have and solving a recurrence relation that gives the linear combination of $e$ and $k$.</p>
<pre class="line-numbers">
<code class="language-python">
# This function gives the linear combination of (x) and (y) in xa + yb = gcd(x,y).
def gcd_linear_combination(x: int, y: int) -> tuple:
    if x > y:
        temp = y
        y = x
        x = temp
    if x == 0:
        return y

    original_x = x
    original_y = y

    coefficient_list = []
    coefficient_list.append((0, 1))
    coefficient_list.append((1, -int(y / x)))

    iteration = 1

    while True:
        r = y % x
        if r == 0:
            break

        # Solve the recurrence relation.
        if iteration != 1:
            quotient = int(y / x)
            a = int(coefficient_list[iteration - 2][0] - (coefficient_list[iteration - 1][0] * quotient))
            b = int(coefficient_list[iteration - 2][1] - (coefficient_list[iteration - 1][1] * quotient))
            coefficient_list.append((a, b))

        y = x
        x = r
        iteration = iteration + 1

    a = coefficient_list[-1][1]
    b = coefficient_list[-1][0]

    # If (a) is negative, make it positive to avoid negative exponents.
    if a < 0:
        i = 2
        while True:
            a_candidate = a + i * original_y
            b_candidate = b - i * original_x

            if a_candidate > 0:
                a = a_candidate
                b = b_candidate
                break
            i = i + 1
    return a, b

# To find (d) for ex + ky = gcd(e,k) = 1:
e = 3
k = 40
x = gcd_linear_combination(e,k)[0]
d = x % k
print(d)  # Output: 27
</code>
</pre>

<div style="height: 1rem;"></div>

<p>Combining those functions we have earlier, we could now generate a public and private key:</p>
<pre class="line-numbers">
<code class="language-python">
def generate_key_pair(first_prime: int = None, second_prime: int = None) -> KeyPair:
    """
    A function that generates a public key and private key.
    Parameters:
    first_prime (int): The first prime number.
    second_prime (int): The second prime number.
    Returns:
    KeyPair: A class that holds the public key and private key.
    """

    prime_pair = rmath.generate_prime_number_list(size=2, shuffle=True)  # Generate two distinct primes.
    if first_prime is None:
        first_prime = prime_pair[0]
        if first_prime == second_prime:
            first_prime = prime_pair[1]
    if second_prime is None:
        second_prime = prime_pair[1]
        if first_prime == second_prime:
            second_prime = prime_pair[0]
    inputchecker.rsa_generate_key_pair(first_prime, second_prime)

    prime_product = first_prime * second_prime
    prime_product_minus_one = (first_prime - 1) * (second_prime - 1)
    public_auxiliary = rmath.find_number_relatively_prime(prime_product_minus_one)
    private_auxiliary = rmath.gcd_linear_combination(public_auxiliary, prime_product_minus_one)[0]

    # The Key class is just a holder for the values of the public and private key.
    public_key = Key(prime_product, public_auxiliary)
    private_key = Key(prime_product, private_auxiliary)
    key_pair = KeyPair(public_key, private_key)

    return key_pair
</code>
</pre>

<div style="height: 1rem;"></div>

<h2>Encrypting and Decrypting Messages</h2>

<p>Encrypting and decrypting a message in RSA is relatively easy and straightforward.</p>

<p>To encrypt a message $m$:</p>
$$m' = m^e\ \textrm{mod}\ n$$

<p>To decrypt:</p>
$$m = (m')^d\ \textrm{mod}\ n$$

<div class="border px-2 py-2">
<h3>Example</h3>

<p>Let's try to encrypt a message $m = 8$ with the following keys:</p>
$$e = 3$$
$$d = 27$$
$$n = 55$$

<p>This means that the value of $m'$ is:</p>
$$m' = 17 = 8^3\ \textrm{mod}\ 55$$

<p>To decrypt $m'$:</p>
$$m = 8 = 17^{27}\ \textrm{mod}\ 55$$
</div>

<div style="height: 1rem;"></div>

<p>If you want to encrypt strings, you could convert each character to their Unicode value (or any other numerical representation of the character) and do the math from there.</p>

<p>Here's how I programmed the encryption and decryption process in Python:</p>
<pre>
<code class="language-python line-numbers">
class Encryptor:
    """
    A class that encrypts data based on the key parameter.
    Parameters:
    public_key (Key): The public key.
    """

    def __init__(self, public_key: Key):
        self.public_key = public_key

    def encrypt(self, message: str) -> str:
        """
        A method that takes a string and encrypts it.
        Parameters:
        message (str): The string to be encrypted.
        Returns:
        str: The encrypted string.
        """

        encrypted_message = ""
        for character in message:
            encrypted_character = chr((ord(character) ** self.public_key.auxiliary) % self.public_key.prime_product)
            encrypted_message = encrypted_message + encrypted_character
        return encrypted_message


class Decryptor:
    """
    A class that decrypts data based on the key parameter.
    Parameters:
    private_key (Key): The private key.
    """

    def __init__(self, private_key: Key):
        self.private_key = private_key

    def decrypt(self, message: str) -> str:
        """
        A method that takes a string and decrypts it.
        Parameters:
        message (str): The string to be decrypted.
        Returns:
        str: The decrypted string.
        """
        decrypted_message = ""
        for character in message:
            decrypted_character = chr((ord(character) ** self.private_key.auxiliary) % self.private_key.prime_product)
            decrypted_message = decrypted_message + decrypted_character
        return decrypted_message
</code>
</pre>

<div style="height: 1rem;"></div>

<p>That's it! We are finally done!</p>

<p>Thanks for reading!</p>

<div style="height: 1rem;"></div>