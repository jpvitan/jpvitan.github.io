<p>
    Primality testing of large numbers plays a significant role in public-key cryptosystems like RSA. In fact, the
    security of RSA relies on two or more large and distinct prime numbers that are often hundreds of digits long. If we
    cannot guarantee the numbers used for RSA are prime numbers, the whole cryptosystem might not function properly or
    work as expected. Thus, it is crucial to have an algorithm that efficiently tests out large numbers for primality.
</p>

<h3 class="mt-5">Deterministic Primality Testing</h3>

<p>
    Deterministic primality tests tell us whether a given number is prime or not with 100% certainty. The Python code
    below shows an example of a deterministic primality test.
</p>

<pre>
<code class="language-python">
# A straightforward but naive way of doing a deterministic primality test
def is_prime(n):
    if n &lt; 2:
        return False
    for i in range(2, int(n ** (0.5)) + 1):
        if n % i == 0:
            return False
    return True
</code>
</pre>

<p>
    The deterministic primality test above has an $O(\sqrt{n})$ runtime which may sound good, but that's not the case if
    the number we are testing is more than a hundred digits long. To demonstrate an example, RSA-2048 would test numbers
    that are this long:
</p>

<pre>
<code class="language-python">
n = 163145567104300729039970253384073317588029379139984064995408978833561087636999920476014308781051531193713832556070474041178382937174476474150199103538166759997692692472889219982769634729915480397457313883064907763838684973672155550942153644743143270024504551276575690516995596509703400794668643641437638889259
</code>
</pre>

<p>
    Taking the square root of $n$ is still a large upper bound for practical cases. Even the best deterministic test may
    not be sufficient for testing numbers as large as the example above. To solve this problem, we will consider using
    probabilistic primality tests, which I will discuss in the following section.
</p>

<h3 class="mt-5">Probabilistic Primality Testing</h3>

<p>
    Probabilistic primality tests often yield a better computational runtime than deterministic primality tests. That's
    why most applications prefer to use them over deterministic ones.
</p>

<p>
    The Miller-Rabin primality test is one of the fastest algorithms we could use to find probable primes. Probable
    primes are integers that are highly unlikely to be composite and behave similarly to prime numbers.
</p>

<pre>
<code class="language-python line-numbers">
def rabin_miller(p: int) -&gt; bool:
    a = random.randint(1, p - 1)
    s = 0
    t = p - 1
    while t % 2 == 0:
        s = s + 1
        t = t // 2
    modulo_result = pow(a, t, p)
    if modulo_result == 1 or modulo_result == p - 1:
        return True
    for i in range(1, s):
        modulo_result = pow(a, 2 ** i * t, p)
        if modulo_result == p - 1:
            return True
    return False
</code>
</pre>

<p>
    The code above is the most common way to implement the Miller-Rabin primality test. The function
    <code>rabin_miller</code> returns a boolean
    value that indicates whether the given input is composite (false) or probable prime (true).
</p>

<p>
    To fully understand what the code does, I'll explain it in a series of steps. I'll use the line numbers indicated
    within the code block to reference parts of the code.
</p>

<h4 class="mt-5">Line 2</h4>

<pre>
<code class="language-python">
a = random.randint(1, p - 1)
</code>
</pre>

<p>
    The code block above assigns a value to our base $a$, a pseudorandom integer from $1$ to $p-1$. We'll use this value
    in the subsequent sections.
</p>

<h4 class="mt-5">Lines 3-7</h4>

<pre>
<code class="language-python">
s = 0
t = p - 1
while t % 2 == 0:
    s = s + 1
    t = t // 2
</code>
</pre>

<p>
    Lines 3-7 transforms our input $p$ into the following form:
</p>

$$p = 2^{s} t + 1$$

<p>
    It is important to note that the value of $t$ should be odd.
</p>

<h4 class="mt-5">Lines 8-10</h4>

<pre>
<code class="language-python">
modulo_result = pow(a, t, p)
if modulo_result == 1 or modulo_result == p - 1:
    return True
</code>
</pre>

<p>
    Lines 8-10 will check if the following congruence relation is true:
</p>

$$a^{t} \equiv \pm 1\ (\textrm{mod}\ p)$$

<p>
    If the equation above is satisfied, we declare $p$ a probable prime because it passes the following criteria:
</p>

<ol>
    <li>
        It passes the Fermat primality test since $a^{t} \equiv \pm 1\ (\textrm{mod}\ p) \implies a^{2^{s} t} \equiv 1\
        (\textrm{mod}\ p)$.
    </li>
    <li>
        If $p$ is an odd prime, then the square roots of $1$ modulo $p$ are $\pm 1$.
    </li>
</ol>

<p>
    If the equation is <strong>not</strong> satisfied, we'll move to lines 11-14 and perform another test that might
    meet the criteria above.
</p>

<h4 class="mt-5">Lines 11-14</h4>

<pre>
<code class="language-python">
for i in range(1, s):
modulo_result = pow(a, 2 ** i * t, p)
if modulo_result == p - 1:
    return True
</code>
</pre>

<p>
    Lines 11-14 will check from $i \in [1,s)$ and see if the following congruence relation is true:
</p>

$$a^{2^{i} t} \equiv -1\ (\textrm{mod}\ p)$$

<p>
    If there's a value of $i$ that would satisfy the equation above, then it is guaranteed to pass the criteria we have
    previously mentioned because of the following fact:
</p>

$$a^{2^{i} t} \equiv -1\ (\textrm{mod}\ p) \implies a^{2^{i+1} t} \equiv 1\ (\textrm{mod}\ p)$$

<p>
    This shows that the square root of $1$ modulo $p$ is $-1$ and passes the Fermat primality test by repeated squaring.
    Hence, we declare $p$ a probable prime.
</p>

<h4 class="mt-5">Line 15</h4>

<pre>
<code class="language-python">
return False
</code>
</pre>

<p>
    Line 15 guarantees that $p$ is composite because all prime numbers would satisfy the conditions in lines 8-10
    or lines 11-14. In this case, we declare $p$ composite.
</p>